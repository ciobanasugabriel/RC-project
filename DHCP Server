import socket
import ipaddress

serverPort = 67
clientPort = 68

MAX_BYTES=1024

dest = ('255.255.255.255', clientPort)
class DHCP_server(object):
    #start_ip = bytes([0xC0, 0xA8, 0x01, 0x01])
    #end_ip = bytes([0xC0, 0xA8, 0x01, 0x65])
    addresses = []
    used_addresses = []
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x01]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x02]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x03]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x04]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x05]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x06]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x07]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x08]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x09]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x0a]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x0b]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x0c]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x0d]))
    addresses.append(bytes([0xC0, 0xA8, 0x01, 0x0e]))

    leases=[]
    for i in range(1, len(addresses)):
        leases.append(bytes([51, 4, 0x00, 0x01, 0x51, 0x80]))

    ip_and_lease=dict(zip(addresses,leases))

    def server(self):
        print("DHCP server is starting")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #AF_INET ne da tipul de adresa(IPv4) si SOCK_DGRAM ne indica tipul de socket folosit(UDP)
        s.bind(("0.0.0.0", serverPort))
        while True:

            print("Wait DHCP discovery.")
            data, address=s.recvfrom(MAX_BYTES)

            if data[244:245] == bytes([0x01]): #DHCPDISCOVERY
                print(f"DHCP discovery received from {address}")
                print("Send DHCP offer.")
                dhcpoffer = DHCP_server.send_offer(self,data) #DHCPOFFER
                s.sendto(dhcpoffer,dest)

                while True:
                    print("Wait DHCP request.")
                    data2, address2 = s.recvfrom(MAX_BYTES)
                    if data2[244:245] == bytes([0x03]): #DHCPREQUEST
                        print(f"DHCP request received from {address2}")
                        print("Send DHCP ack.")
                        dhcpack= DHCP_server.send_ack(self,data2)     #DHCPACK
                        s.sendto(dhcpack, dest)
                        break

    def send_offer(self,received_pack):
        OP = bytes([0x02])  # 1 for messages sent by a client 2 for messages sent by a server
        HTYPE = bytes([0x01])  # ethernet type is specified when HTYPE=1
        HLEN = bytes([0x06])  # for ethernet the value is 6
        HOPS = bytes([0x00])  # Client sets to zero, optionally used by relay-agents
        XID = bytes([0x39, 0x03, 0xF3, 0x26])  # Transaction ID, a random number chosen by the client, used by the client and server to associate messages and responses between a client and a server.
        SECS = bytes([0x00, 0x00])  # Filled in by client, seconds elapsed since client started trying to boot.
        FLAGS = bytes([0x00, 0x00])  # can be set to 1 to indicate that messages to the client must be broadcast
        CIADDR = bytes([0x00, 0x00, 0x00, 0x00])  # Client's IP address; set by the client when the client has confirmed that its IP address is valid.
        YIADDR = bytes([0x00, 0x00, 0x00, 0x00])
        if received_pack[12:16] == CIADDR:
            for k in DHCP_server.addresses:
                if k not in DHCP_server.used_addresses:
                    YIADDR = k
                    DHCP_server.used_addresses.append(k)
                    break
        else:
            if received_pack[12:16] in DHCP_server.used_addresses:
                for k in DHCP_server.addresses:
                    if k not in DHCP_server.used_addresses:
                        YIADDR = k
                        DHCP_server.used_addresses.append(k)
                        break
            else:
                if received_pack[12:16] in DHCP_server.addresses:
                    YIADDR = received_pack[12:16]

        SIADDR = bytes([0x00, 0x00, 0x00, 0x00])  # IP address of the next server for the client to use in the configuration process
        GIADDR = bytes([0x00, 0x00, 0x00, 0x00])  # Relay agent (gateway) IP address; filled in by the relay agent with the address of the interface through which Dynamic Host Configuration Protocol (DHCP) message was received.

        # client hardware addresses
        CHADDR1 = bytes([0x00, 0x05, 0x3C, 0x04])
        CHADDR2 = bytes([0x8D, 0x59, 0x00, 0x00])
        CHADDR3 = bytes([0x00, 0x00, 0x00, 0x00])
        CHADDR4 = bytes([0x00, 0x00, 0x00, 0x00])
        CHADDR5 = bytes(192)

        Magiccookie = bytes([0x63, 0x82, 0x53, 0x63])
        pack = OP+HTYPE+HLEN+HOPS+XID+SECS+FLAGS+CIADDR+YIADDR+SIADDR+SIADDR+GIADDR+CHADDR1+CHADDR2+CHADDR3+CHADDR4+CHADDR5+Magiccookie
        return pack


    #de refacut
    def send_ack(self,received_pack):
        OP = bytes([0x02])  # 1 for messages sent by a client 2 for messages sent by a server
        HTYPE = bytes([0x01])  # ethernet type is specified when HTYPE=1
        HLEN = bytes([0x06])  # for ethernet the value is 6
        HOPS = bytes([0x00])  # Client sets to zero, optionally used by relay-agents
        XID = bytes([0x39, 0x03, 0xF3,
                     0x26])  # Transaction ID, a random number chosen by the client, used by the client and server to associate messages and responses between a client and a server.
        SECS = bytes([0x00, 0x00])  # Filled in by client, seconds elapsed since client started trying to boot.
        FLAGS = bytes([0x00, 0x00])  # can be set to 1 to indicate that messages to the client must be broadcast
        CIADDR = bytes([0x00, 0x00, 0x00,
                        0x00])  # Client's IP address; set by the client when the client has confirmed that its IP address is valid.
        if received_pack[12:16] == CIADDR:
            for k in DHCP_server.addresses:
                if k not in DHCP_server.used_addresses:
                    YIADDR = k
                    DHCP_server.used_addresses.append(k)
                    break
        else:
            if received_pack[12:16] in DHCP_server.used_addresses:
                for k in DHCP_server.addresses:
                    if k not in DHCP_server.used_addresses:
                        YIADDR = k
                        DHCP_server.used_addresses.append(k)
                        break
            else:
                if received_pack[12:16] in DHCP_server.addresses:
                    YIADDR = received_pack[12:16]

        SIADDR = bytes([0x00, 0x00, 0x00,
                        0x00])  # IP address of the next server for the client to use in the configuration process
        GIADDR = bytes([0x00, 0x00, 0x00,
                        0x00])  # Relay agent (gateway) IP address; filled in by the relay agent with the address of the interface through which Dynamic Host Configuration Protocol (DHCP) message was received.

        # client hardware addresses
        CHADDR1 = bytes([0x00, 0x05, 0x3C, 0x04])
        CHADDR2 = bytes([0x8D, 0x59, 0x00, 0x00])
        CHADDR3 = bytes([0x00, 0x00, 0x00, 0x00])
        CHADDR4 = bytes([0x00, 0x00, 0x00, 0x00])
        CHADDR5 = bytes(192)

        Magiccookie = bytes([0x63, 0x82, 0x53, 0x63])
        pack = OP + HTYPE + HLEN + HOPS + XID + SECS + FLAGS + CIADDR + YIADDR + SIADDR + SIADDR + GIADDR + CHADDR1 + CHADDR2 + CHADDR3 + CHADDR4 + CHADDR5 + Magiccookie
        return pack


if __name__ == '__main__':
    dhcp_server = DHCP_server()
    dhcp_server.server()
